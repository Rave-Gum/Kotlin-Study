## 추상 클래스와 인터페이스
- 추상클래스(Abstract Class)
    - 구현 클래스에서 가져야할 명세를 정의한 클래스
    - `abstract`라는 키워드와 함께 선언하며 추상클래스는 객체 생성 안됨
    - '구체적이지 않은 것'을 나타내기 때문에 하위 파생 클래스에서 구체적으로 구현
    - `open` 키워드를 사용하지 않고도 파생 클래스 작성 가능
    - object를 사용한 생성
        - 추상 클래스로부터 하위 클래스를 생성하지 않고 단일 인스턴스로 객체 생성 가능
- 인터페이스(Interface)
    - 추상클래스와 다른점
        - 클래스가 아니므로 다양한 인터페이스로부터 클래스 구현 가능(다중 상속)
        - 추상 클래스와는 다르게 강한 연관을 가지지 않는다.
    - 코틀린의 인터페이스
        - 다른 언어와 다르게 기본적인 구현 내용이 포함될 수 있다.
            - 자바에서는 버전 8에서 default 키워드를 사용해야만 구현 내용 포함
        - 선언하려면 interface 키워드를 사용해 정의
        - 상속한 하위 클래스에서는 override를 사용해 해당 메서드를 구현
        - `abstract` 키워드가 없어도 기본은 추상 프로퍼티
    - 게터를 통한 구현
        - 인터페이스에서는 프로퍼티에 값을 저장할 수 없지만 val로 선언된 프로퍼티는 게터를 통해 필요한 내용을 구현할 수 있다.
    - 다중상속
        - 클래스는 기본적으로 다중 상속을 지원하지 않는다.
        - 인터페이스는 여러 개를 하나의 클래스에서 구현하는 것이 가능하므로 다중 상속과 같은 효과를 가진다.
    - 인터페이스의 위임 사용

    ```kotlin
    interface A {
        fun funtionA(){}
    }
    interface B {
        fun funtionB(){}
    }
    class C(val a: A, val b: B) {
        fun functionC() {
            a.functionA()
            b.functionB()
        }
    }
    ```

    ```kotlin
    class DelegatedC(a: A, b: B): A by a, B by b {
        fun functionC() {
            functionA() // A의 위임
            functionB() // B의 위임
        }
    }
    ```

## 데이터 클래스와 기타 클래스
- 데이터 전달을 위한 객체 DTO(Data Transfer Object)
    - 자바에서는 POJO(Plain Old Java Object)라고 불리기도 함
    - 구현 로직을 가지고 있지 않고 순수한 데이터 객체를 표현
    - 데이터를 접근하는 게터 / 세터를 포함
    - `toString()`, `equals()` 등과 같은 데이터 표현 및 비교 메서드 포함
- 코틀린의 데이터 클래스(Data Class)
    - DTO를 표현하기 적합한 클래스 표현으로 data class 키워드를 사용해 정의

    > 코틀린의 프로퍼티 = 필드 (변수) + 게터와 세터

- 데이터 클래스의 조건
    - 주 생성자는 최소한 하나의 매개변수를 가져야 한다.
    - 주 생성자의 모든 매개변수는 `val`, `var`로 지정된 프로퍼티여야 한다.
    - 데이터 클래스는 `abstract`, `open`, `sealed`, `inner` 키워드를 사용할 수 없다.
- 간단한 로직 포함 하려면
    - 부 생성자나 `init` 블록을 넣어 데이터를 위한 간단한 로직 포함 가능
- 자동 생성되는 메서드
    - `equals()` - 두 객체의 내용이 같은지 비교
    - `hashCode()` - 객체를 구별하기 위한 고유한 정수값 생성
    - `copy()` - 빌더 없이 특정 프로퍼티만 변경해서 객체 복사
    - `toString()` - 데이터 객체를 읽기 편한 문자열로 반환
    - `componentN()` - 객체의 선언부 구조를 분해하기 위해 프로퍼티에 상응하는 메서드
- 디스트럭처링(Destructuring)
    - 객체가 가지고 있는 프로퍼티를 개별 변수들로 분해

    ```kotlin
    val (name, email) = cus1
    println("name = $name, email = $email")

    val (_, email) = cus1 // 첫 번째 프로퍼티 제외
    ```

- `componentN()` 메서드

    ```kotlin
    val name2 = cus1.component1()
    val email2 = cus1.component2()
    println("name = $name2, email = $email2")
    ```

- 코틀린 내부 클래스 종류
    - 중첩(Nested) 클래스 - 객체 생성 없이 사용 가능(외부 클래스의 프로퍼티, 메서드에 접근 불가능, 자바의 정적 클래스처럼 동작)
    - 이너(Inner) 클래스 - 필드나 메서드와 연동하는 내부 클래스
- 지역 클래스(Local Class)
    - 특정 메서드의 블록이나 `init` 블록과 같이 블록 범위에서만 유효한 클래스
    - 블록 범위를 벗어나면 더 이상 사용되지 않음
- 익명 객체 (Anonymous Object)
    - 자바에서는 익명 이너 클래스라는 것을 제공해 일회성으로 객체를 생성해 사용
    - 코틀린에서는 `object`키워드를 사용하는 익명 객체로 같은 기능을 수행
- 실드 클래스(Sealed Class)
    - 값이 제한된 집합의 유형 중 하나를 가질 수 있지만 다른 유형을 가질 수 없는 제한된 클래스 계층 구조를 나타내는데 사용
    - 실드 클래스 그 자체로는 추상 클래스와 같기 때문에 객체를 만들 수 없음
    - 생성자는 기본적으로 `private`고 다른 접근 제한자를 가질 수 없음
    - 실드 클래스의 장점은 `when`문 사용시 `else`절이 필요없음
- 열거형 클래스 (Enum Class)
    - 여러 개의 상수를 선언하고 열거된 값을 조건에 따라 선택할 수 있는 특수한 클래스
    - 자료형이 동일한 상수를 나열할 수 있다.
        - 실드 클래스처럼 다양한 자료형을 다루지 못한다.
- 애노테이션 클래스 (Annotation Class)
    - 코드에 부가 정보를 추가하는 기능 역할
    - `@` 기호와 함께 나타내는 표기법으로 주로 컴파일러나 프로그램 실행 시간에 사전 처리를 위해 사용

## 연산자 오버로딩
- 연산자 오버로딩(operator overloading)
    - 연산자에 여러 가지 다른 의미의 작동을 부여
    - 코틀린에서는 특정 연산자의 역할을 함수로 정의
    - `operator` 키워드를 사용해 정의
- 인덱스 연산자(indexed access operator)
    - 게터 / 세터를 다루기 위한 대괄호 연산자 제공
- 단일 연산자
    - 먼저 a의 자료형을 결정하고 매개변수 없이 각 연산자에 대한 함수를 호출한 다음 연산된 결과를 반환
- 포함 범위 연산자
    - `in` 연산자는 반복문에 사용해 특정 객체의 반복에 사용 혹은 포함여부 판단
- 할당 연산자(Augmented Assignments)
    - `+=` , `-=` , `/=`, `%=`
- 동등 연산자(Equality And Inequality)
    - `==` , `!=`
- 비교 연산자(Comparison)
    - `<`, `>`, `>=`, `<=`